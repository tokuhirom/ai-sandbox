#!/bin/bash
set -euo pipefail

usage() {
  echo "Usage: ai-sandbox [--set-window-title] [--recreate] [--dry-run] <branch> [claude|codex|bash] [args...]" >&2
  exit 1
}

SET_WINDOW_TITLE=false
RECREATE=false
DRY_RUN=false
while [[ "${1:-}" == --* ]]; do
  case "$1" in
    --set-window-title) SET_WINDOW_TITLE=true; shift ;;
    --recreate)         RECREATE=true; shift ;;
    --dry-run)          DRY_RUN=true; shift ;;
    *)                  break ;;
  esac
done

BRANCH="${1:?$(usage)}"
TOOL="${2:-bash}"
shift 2 2>/dev/null || shift $#
EXTRA_ARGS=("$@")

# .git のあるディレクトリを探す
find_repo_root() {
  local dir="$PWD"
  while [[ "$dir" != "/" ]]; do
    if [[ -d "$dir/.git" ]]; then
      echo "$dir"
      return
    fi
    dir="$(dirname "$dir")"
  done
  echo "Error: not in a git repository" >&2
  exit 1
}

REPO_ROOT="$(find_repo_root)"
WORKTREE_DIR="${REPO_ROOT}/.git/worktrees-sandbox/${BRANCH}"

# --recreate: 既存 worktree を削除して作り直す
if [[ "$RECREATE" == true && -d "$WORKTREE_DIR" ]]; then
  echo "Removing existing worktree for branch '${BRANCH}'..."
  git -C "$REPO_ROOT" worktree remove --force "$WORKTREE_DIR"
  # ブランチも削除 (再作成時に origin の最新から作り直すため)
  git -C "$REPO_ROOT" branch -D "$BRANCH" 2>/dev/null || true
fi

# worktree がなければ作成
if [[ ! -d "$WORKTREE_DIR" ]]; then
  # ブランチ作成元を origin の最新に合わせる
  DEFAULT_BRANCH="$(git -C "$REPO_ROOT" symbolic-ref --short HEAD 2>/dev/null || echo "main")"
  echo "Fetching origin/${DEFAULT_BRANCH}..."
  if git -C "$REPO_ROOT" fetch origin "$DEFAULT_BRANCH" 2>/dev/null; then
    git -C "$REPO_ROOT" update-ref "refs/heads/${DEFAULT_BRANCH}" "origin/${DEFAULT_BRANCH}" 2>/dev/null || true
  else
    echo "Warning: could not fetch from origin (offline?), using local state" >&2
  fi

  echo "Creating worktree for branch '${BRANCH}'..."
  git -C "$REPO_ROOT" worktree add "$WORKTREE_DIR" "$BRANCH" 2>/dev/null \
    || git -C "$REPO_ROOT" worktree add -b "$BRANCH" "$WORKTREE_DIR"
  git -C "$WORKTREE_DIR" submodule update --init --recursive
fi

case "$TOOL" in
  claude) CMD_ARGS=("claude" "--dangerously-skip-permissions" "${EXTRA_ARGS[@]}") ;;
  codex)  CMD_ARGS=("codex" "--dangerously-bypass-approvals-and-sandbox" "${EXTRA_ARGS[@]}") ;;
  bash)   CMD_ARGS=("bash" "${EXTRA_ARGS[@]}") ;;
  *)      echo "Unknown tool: $TOOL" >&2; usage ;;
esac

BWRAP_ARGS=(
  # システム領域を読み取り専用でマウント (/home を除く)
  --ro-bind /usr /usr
  --ro-bind /bin /bin
  --ro-bind /sbin /sbin
  --ro-bind /lib /lib
  --ro-bind /lib64 /lib64
  --ro-bind /etc /etc
  --ro-bind /run /run
  --dev /dev
  --proc /proc
  --tmpfs /tmp
  --tmpfs /home
)

# 存在する場合のみマウントするシステムディレクトリ
for dir in /opt /snap /nix /lib32; do
  [[ -d "$dir" ]] && BWRAP_ARGS+=(--ro-bind "$dir" "$dir")
done

BWRAP_ARGS+=(
  # HOME 配下: 必要なディレクトリのみ公開
  --ro-bind "${HOME}/.local/share/mise" "${HOME}/.local/share/mise"
  --ro-bind "${HOME}/.local/share/claude" "${HOME}/.local/share/claude"
  --ro-bind "${HOME}/.local/bin" "${HOME}/.local/bin"
  --ro-bind "${HOME}/.rustup" "${HOME}/.rustup"
  --bind "${HOME}/.cargo" "${HOME}/.cargo"
  --ro-bind "${HOME}/.gitconfig" "${HOME}/.gitconfig"
  --ro-bind "${HOME}/.config/gh" "${HOME}/.config/gh"
  --bind "${HOME}/.claude" "${HOME}/.claude"
  --bind "${HOME}/.claude.json" "${HOME}/.claude.json"
  --bind "${HOME}/.codex" "${HOME}/.codex"
  # worktree と .git だけ書き込み可能
  --bind "${WORKTREE_DIR}" "${WORKTREE_DIR}"
  --bind "${REPO_ROOT}/.git" "${REPO_ROOT}/.git"

  --share-net
  --unshare-pid
  --die-with-parent
  --chdir "${WORKTREE_DIR}"
  --setenv HOME "${HOME}"
  --setenv GH_TOKEN "${GH_TOKEN:-}"
)

# tmux のウィンドウ名をブランチ名に設定 (--set-window-title 指定時のみ)
if [[ "$SET_WINDOW_TITLE" == true && -n "${TMUX:-}" ]]; then
  case "$TOOL" in
    claude) TMUX_PREFIX="cl" ;;
    codex)  TMUX_PREFIX="cx" ;;
    bash)   TMUX_PREFIX="sh" ;;
  esac
  tmux rename-window "${TMUX_PREFIX}:${BRANCH}"
fi

# --dry-run: 設定内容を表示して終了
if [[ "$DRY_RUN" == true ]]; then
  echo "=== ai-sandbox configuration ==="
  echo "Repository:  ${REPO_ROOT}"
  echo "Branch:      ${BRANCH}"
  echo "Worktree:    ${WORKTREE_DIR}"
  echo "Tool:        ${TOOL}"
  echo "GH_TOKEN:    $([[ -n "${GH_TOKEN:-}" ]] && echo "set" || echo "(not set)")"
  echo "Command:     ${CMD_ARGS[*]}"
  echo ""
  echo "=== bwrap command ==="
  echo "bwrap ${BWRAP_ARGS[*]} ${CMD_ARGS[*]}"
  exit 0
fi

exec bwrap "${BWRAP_ARGS[@]}" "${CMD_ARGS[@]}"
